## まえがき

これを書くきっかけとなったのは、Webエンジニアとして働いている会社で中途採用の方に、どうやってLinuxの使い方を教えるかを考えたからだ。

Linuxと言ってもリモートサーバにSSHログインしてファイルを書き換える…程度のことなのだが、SSHやLinuxを一切触ったことがない方に教えるのはなかなか片手間では難しい。

SSHやLinuxも最低限使えるようになってほしいが、教えられた作業しかできないというのも教える側教えられる側双方にとっても不幸だろう。

とはいえ基礎の基礎から学んでもらいどんな作業もできるようにするのは、コンピュータサイエンスに慣れていない方にとってはかなり難しい。

そこである程度ゆるく（基礎から学ぶと時間がかかるので）基本を学んでもらい、そこから先は検索したり人に聞いたり本を読んだりして進めてもらうのがよいのではないかと思い至った。

この文章がLinuxの基礎を知らない・もしくは自信がないアプリケーションエンジニアの一助になることを願ってやまない。

## 始めに

これから学ぶLinuxと皆さんが使っているWindowsやMacの違いというのはなんだろう。

どちらもOSには変わりないが一番大きな違いはLinuxの場合基本的には文字だけの世界ということだ（一応WindowsやMacのようにグラフィカルな画面を出して操作できる）。

どういうことかというと、Linuxではマウス、ウィンドウや壁紙も存在しない。表示はすべて文字だからこちらの操作も文字で行うのだ。こちらで行う文字の操作をコマンドという。

なのでLinuxを使う場合は基本的にコマンドを駆使して操作することになる。コマンドを知らないと操作ができないので敷居は高いが、慣れればマウスで操作するより早く複雑な操作が行える。


たとえばファイルを別の場所にコピーしたいとき、Windowsならファイルを右クリックしてコピーを選択し、コピーしたい場所で右クリックして貼り付けを選択する。これがLinuxだと次のコマンドでコピーの操作する。

```bash
cp (コピーしたいファイルの場所) (コピー後のファイルの場所)
```

このコマンドを実行することで、「コピーしたいファイル場所」にあるファイルが「コピーしたいファイル場所」にコピーされる。

コピー後のファイル名を変えたい場合は「コピー後のファイルの場所」に変更後のファイル名も書いておくとその名前でコピーされる。また、コピー先に同名ですでにファイルがあったときコピーしない・上書きでコピーするや、コピー先よりコピー元のほうが新しいときのみコピーしたりさまざまなオプションも用意されている。

このようにコマンドとオプションを覚えておかないといけないという敷居はあるものの、覚えてしまえばマウスで操作するよりずっと早くいろんな作業を行える。

Linuxを使う方は基本的にエンジニアなのでマウスのような親切な操作体系は存在せず、無骨ながらも機能的な操作体系が用意されている。この操作体系に慣れていただきバリバリ仕事をこなしていただければ幸いである。


## Linuxについて

### シェルについて

コマンドを実行したりコマンドの結果が表示したりするプログラムをシェルという。シェルには何種類もあるが、一般的なのは`bash`や`zsh`というシェルでたいていはどちらかのプログラムが標準搭載されている。

`bash`の場合コマンドの入力表示はこのような表示になっている。

```
[takahashi.t@hostname ~]$ 
```

ここで、@以前の`takahashi.t`はログインしているユーザー名を表している。@以後の`hostname`はログイン中Linuxのホスト名を表している。
また、ホスト名の次の`~`はカレントディレクトリ（後述）のことで、今いるディレクトリを表している。

### コマンドの基礎

コマンドにはオプションと引数を付けて実行できる。

前の章で紹介したコピーのコマンド"cp"を例に取ると、書式としてはこうなる。

```bash
cp オプション 引数1 引数2 引数3 ....
```

オプションはファイルの上書き前に上書きしてよいか確認したり、コピー先のファイルよりコピー元のファイルのほうが新しいときだけコピーするなどができる。詳しくは、"man cp"などでGoogle検索すると出てくる。

オプションの前には"-"をつけるのが決まりだ。これが引数でなくオプションの指定であるという印になる。オプションは複数指定できる。

引数は"cp"コマンドの場合無数に指定できる。オプションにもよるが、最後の引数はコピー先のディレクトリで、それ以外の引数はコピーするファイルを示す。

上書き前に確認、コピーした結果を表示という2つのオプションを指定し、"テキストファイル.txt"のファイルを"テキストファイル2.txt"にコピーする場合、次のコマンドを実行する。

```bash
cp -iv テストファイル.txt テストファイル2.txt
```

<!-- textlint-disable -->
このときコマンド、オプション、引数の間は半角スペースを入れて区切る。もしファイル名に半角スペースが入っている場合はファイル名を"(ダブルクオート)でくくるか、半角スペースの前にバックスラッシュを入れるとよい。たとえば次のようにする。
<!-- textlint-enable -->

```bash
cp テストファイル.txt "テスト　ファイル.txt"
cp テストファイル.txt テスト\　ファイル.txt
```

### ファイルとディレクトリについて

#### ファイルについて

WindowsやMacで何気なく使っているファイルやディレクトリも当然文字として表現されるし、文字として操作する。

ファイルはそのままファイル名として表現、操作する。

"テストファイル.txt"というファイルがあれば、それはそのまま"テストファイル.txt"と表示されるし、操作するときも"テストファイル.txt"と入力すればよい。

前の章で紹介したコピーのコマンド"cp"を使って、"テストファイル.txt"を"テストファイル2.txt"に名前を変えてコピーするときは次のようにする。

```bash
cp テストファイル.txt テストファイル2.txt
```

また"\*" (アスタリスク)という文字はLinuxにとって特別な意味を持つ文字となる。これは任意の一文字以上の文字を意味するものだ。ワイルドカードとも呼ばれる。

一度に複数のファイルをコマンドに指示したいとき、この"\*"を使うとよい。

たとえば"ファイル1.txt"から"ファイル10.txt"までのファイルがある場合、"ファイル*"とすればすべてのファイルを選んだことになる。

ただし、先述の例の場合"ファイル.pdf"のようなファイルも選んでしまうことになる。そういった場合は"ファイル*.txt"とすればよいだろう。

#### ディレクトリについて

ディレクトリというのはWindowsでいうところのフォルダという概念である。

Linuxでは"ディレクトリ名/ディレクトリ名"と、/(スラッシュ)区切りでディレクトリを表現する。

また、自分が今いるディレクトリはカレントディレクトリといって.(ドット)で表現する。自分が今いるディレクトリのひとつ上のディレクトリは..で表現する。

最上位階層のディレクトリはルートディレクトリと言って/(スラッシュ)で表現する。

最後に表現方法だが、絶対パスと相対パスの2種類存在する。

##### 絶対パス

絶対パスは、目的のファイルやディレクトリをルートディレクトリから表現したものになる。

ルートディレクトリを/で表現し、ディレクトリ名を/区切りで連ねていく。最後に目的のファイル名かディレクトリ名を追加すれば絶対パスとなる。

たとえばこうなる。

```bash
/home/takahashi.t/testfile.txt
```

##### 相対パス

相対パスは、目的のファイルやディレクトリを自分が今いるディレクトリから表現したものになる。

自分が今いるディレクトリを.で表現して、ディレクトリ名を/区切りで連ねていく。最後に目的のファイル名かディレクトリ名を追加すれば相対パスとなる。

カレントディレクトリが/homeの場合たとえばこうなる。

```bash
takahashi.t/testfile.txt
./takahashi.t/testfile.txt
../home/takahashi.t/testfile.txt
```

##### ホームディレクトリ

ホームディレクトリとは各ユーザーに割り当てられる専用ディレクトリのこと。ログインしたとき最初にいるディレクトリとなる。
Linuxでは一般に`/home/ユーザ名`となっている。
また`~`(チルダ)で表すこともできる。
例でいうとtakahashi.tというユーザーのホームディレクトリは、`/home/takahashi.t`であり、`~`とも表せる。

### 基本的なコマンドについて

Linuxではすべての操作をコマンドで行う。したがってコマンドを知っていないとその操作はできないということになる。

よく使うコマンドを紹介するので最低限この覚えておけば大丈夫だ。

#### ls

ファイルやディレクトリの名前を表示するコマンド。
引数には名前を表示したいファイルやディレクトリを1つ以上指定できる。アスタリスクなどのワイルドカードを使うことも多い。
引数を省略した場合はカレントディレクトリが指定されたことになる。

##### 使い方

```bash
ls オプション 引数1 ...
```

##### よく使うオプション

* a ... 隠しファイル(ドットで始まるファイルとディレクトリ)も表示する。
* l ... ファイルとディレクトリの更新日時や権限も表示する。

##### 例

```bash
ls -la ディレクトリ1/ディレクトリ2
```

<!-- textlint-disable -->
#### less
<!-- textlint-enable -->

ファイルの中身を表示するコマンド。
引数には名前を表示したいファイルを1つ以上指定できる。アスタリスクなどのワイルドカードを使うことも多い。
スクロールは下方向1行分が`j`、上方向1行分が`k`、下方向1画面分が`Control+f`、上方向1画面分が`Control+b`で行う。
表示をやめるには`q`で、引数に複数ファイルを指定した場合の移動は次ファイルが`:n`、前ファイルが`:p`となっている。

##### 使い方

```bash
less オプション 引数1 ...
```

##### よく使うオプション

* 特になし

##### 例

```bash
less ディレクトリ1/ファイル名.txt
```

#### cd

カレントディレクトリを変更するコマンド。
引数には移動先のディレクトリを指定する。ディレクトリの指定は相対パス、絶対パスでも可能。

##### 使い方

```bash
cd 引数1
```

##### 例

```bash
cd ディレクトリ1
cd ../ディレクトリ1/ディレクトリ2
cd /ディレクトリ1/ディレクトリ2
```

<!-- textlint-disable -->
#### cat
<!-- textlint-enable -->

ファイルの中身を表示するコマンド。
`less`コマンドとは違い、こちらはファイルの中身が一気にそのまま表示される。
引数には表示したいファイルを指定する。

##### 使い方

```bash
cat オプション 引数1 ...
```

##### よく使うオプション

* 特になし

##### 例

```bash
cat ディレクトリ1/ファイル名.txt
```

<!-- textlint-disable -->
#### grep
<!-- textlint-enable -->

ファイルの中身を検索するコマンド。
引数には検索したいファイルやディレクトリを指定する。
引数1は検索する文字を、引数2には検索したいファイルやディレクトリを指定する。

##### 使い方

```bash
grep オプション 引数1 引数2...
```

##### よく使うオプション

* R ... 指定したディレクトリの下位階層をすべて対象とする

##### 例

```bash
grep -R "aaa" .
```

<!-- textlint-disable -->
#### find
<!-- textlint-enable -->

ファイルを検索するコマンド。
引数1に検索したいディレクトリを指定する。引数2には検索条件を指定する。
検索条件には多様な条件が指定でき、一例を上げると名前、作成日、更新日、最終アクセス日、ファイルタイプ、ファイルサイズなどが挙げられる。

##### 使い方

```bash
find オプション 引数1... 引数2
```

##### よく使うオプション

* 特になし

##### 例

```bash
find . -name "*.txt"
```

### パイプについて

パイプとはコマンドの結果出力メッセージを別のコマンドの入力に渡す機能である。
書式は次の通りで、コマンドとコマンドの間を`|`で結ぶ。

```bash
command1 | command2
```

ここでいう入力とはオプションや引数のことではなく、専門用語で言うところの標準入力のことである。
標準入力のことは自力で調べていただくとして、その標準入力を今まで学んできた引数に変換するには`xargs`というコマンドを使って次のようにする。

```bash
command1 | xargs command2
```

具体的な例を出すと、ファイルを検索する`find`と`grep`を組み合わせて、ファイル名に合致するものを`find`で探してファイルの中身の検索を`grep`で行う事ができる。

この時`find`でファイル名に合致するファイルが出力される。
これを`xargs`で引数に変換することで、`grep`の引数にこのファイルが指定されたことになるのだ。

たとえば次のコマンドを入力することで、カレントディレクトリの配下にある".txt"で終わるファイル名に対して"今年度予算"という行があるファイルを探す事ができる。

```bash
find . -name "*.txt" | xargs grep "今年度予算"
```

### 権限について

Linuxでは、すべてのファイルとディレクトリに誰がどういう操作を行えるか設定されている。

権限不足でアプリケーションが動かないといったトラブルはよくあることなのでしっかり理解してほしい。

`ls -l .`もしくは`ls -l`でカレントディレクトリのファイルとディレクトリの権限を表示できる。
出力表示は次のようなものになる。これを例にとって説明する。

```
[takahashi.t@localhost ~]$ ls -l
total 0
drwxr-xr-x 2 takahashi.t engineer 6 Jul 27 08:58 testdirectory
-rw-r--r-- 1 takahashi.t engineer 0 Jul 27 08:58 testfile
```

左端からスペース区切りで順に見ていく。

最初の`drwxr-xr-x`と`-rw-r--r--`はファイルかディレクトリかと権限を表している。
最初の一文字はファイルなのかディレクトリなのかを表している。`d`ならディレクトリで`-`ならファイルとなる。

以降の9文字は権限を表していて、3文字ずつ区切って見る。
最初の3文字が所有者、次が所有グループ、最後がそのほかだ。
所有者とはファイルとディレクトリの所有者のことで、通常作成した人が所有者となる(後で説明するがスペース区切りで3番目のフィールドが所有者を表している)。
所有グループも所有者と同様作成した人が所属しているグループが通常設定される。
最後のそのほかは所有者、所有グループ以外の場合の権限だ。

次に読み方だが、`r`は読み取り、`w`は書き込み、`x`は実行を表している。
つまり、`rwxr-xr-x`は所有者に読み取り・書き込み・実行の権限があり、それ以外は読み取りと実行の権限のみを付けていることになる。

残りのフィールドは左から順に、ハードリンク数、所有者、グループ、ファイルサイズ、タイムスタンプ、ファイル名・ディレクトリ名となっている。

#### 権限の変更

ファイルやディレクトリに設定されている権限を変更するには`chmod`と`chown`コマンドを使用する。

##### アクセス権限の変更

誰に何を許可するというアクセス権限を変更するには`chmod`コマンドを使用する。
たとえば先の例で上げた`rwxr-xr-x`を`r-xr-xr-x`に変更する場合だ。

権限の追加の場合次になる。
`chmod アクセス権限を変更する対象+追加するアクセス権限 ファイル・ディレクトリ名`
また権限の削除は次になる。
`chmod アクセス権限を変更する対象-削除するアクセス権限 ファイル・ディレクトリ名`

アクセス権限を変更する対象を所有者なら`u`、グループなら`g`、そのほかなら`o`として表現する。
アクセス権限はそのまま読み取りなら`r`、書き込みは`w`、実行は`x`と表現する。

したがって`rwxr-xr-x`を`r-xr-xr-x`に変更する場合は次のようになる。
`chmod u-w ファイル・ディレクトリ名`

##### 所有者の変更

ファイルの所有者・所有グループを変更するには`chown`コマンドを使用する。
`chmod`に比べるとシンプルで、下記書式となる。
`chown 所有者:所有グループ ファイル・ディレクトリ名`

したがって、次のようなファイルがあるとする。
`-rw-r--r-- 1 takahashi.t engineer 0 Jul 27 08:58 testfile`
この時に次のようにしたい場合。
`-rw-r--r-- 1 newbie engineer 0 Jul 27 08:58 testfile`
`chown`は次になる。
`chown newbie:engineer testfile`
もしくはグループ名を省略して次のようにしても良い。
`chown newbie testfile`

### リモートログイン (SSH) について

LinuxではほかのLinuxにリモートログインできる。これは主に本番やステージング環境にアクセスしたり、バッチサーバにログインしてバッチを実行したりするのに使われる。
一般に次のようにすれば接続先にログインできる。

```
ssh ユーザ名@接続先
```

ここで接続先はIPアドレスやホスト名を指定する。
接続先のサーバによっては秘密鍵の指定が必要で、その場合は`i`オプションで鍵の場所を指定する。

```
ssh -i 秘密鍵 ユーザ名@接続先
```

リモートログインが完了するとシェルの表示がログイン先のLinuxのものに変わる。

秘密鍵の指定やユーザー名の指定が面倒な場合はホームディレクトリ下の`.ssh`ディレクトリに、configというファイルを用意して設定を記載することで省略できる。

リモートログインをやめる場合は`exit`コマンドを実行する。

### 環境変数について

WindowsやMacしか使ったことがない方はあまり馴染みがない環境変数という概念がある。
環境変数とはたとえば`HOGE=hage`というような、キー(`HOGE`)と値(`hage`)の組み合わせを指す。慣習的にキーは大文字とすることが多い。
あるLinuxによって、またユーザーによって異なる値を格納したい時環境変数を使う。
たとえばデフォルトで`HOME=/home/takahashi.t`という環境変数が設定されている。これはユーザーによって異なるホームディレクトリの場所を示している。

#### 設定方法

設定方法はいくつかあり、またシェル毎に設定方法が違うが、bashの場合は次のコマンドで定義できる。

シェルが起動している間有効にしたい場合 (再起動したり別にシェルを立ち上げるとそのシェルでは無効になる)。
```
export HOGE=hage
```

コマンドを実行するときだけそのコマンドに対してのみ有効にしたい場合。
```
HOGE=hage (実行したいコマンド)
```

再起動したり別にシェルを立ち上げたりしても有効にしたい場合は、ホームディレクトリの`.bashrc`というファイルに上記`export`コマンドを記載すると良い。


#### 確認方法

設定されている環境変数のリストは`env`コマンドを実行すると出力される。
ある特定の環境変数を確認したい場合は`echo`コマンドを使い、確認したい環境変数のキーの頭に`$`を付けて実行する。
```
echo $HOGE
```

#### PATHについて

環境変数として1PATH1というキーにディレクトリを設定すると、ファイル（主に実行ファイル）までのディレクトリを省略できる。
たとえば、`/dir1/dir2/dir3/dir4/`というディレクトリの中にある`execfile`というファイルを実行する場合、通常実行コマンドは次になる。

```
/dir1/dir2/dir3/dir4/execfile
```

しかし、`PATH`に次のように設定した場合。

```
PATH=/dir1/dir2/dir3/dir4
```

こう実行できるようになる。

```
execfile
```

これはシェルがコマンドを渡されたときに、まずカレントディレクトリに`execfile`がないか探して、なければ`PATH`で設定されているディレクトリから探すためである。
なおディレクトリを複数設定したい場合は次のように`:`で区切る。

```
/dir1/dir2:/dir10/dir20
```

たいていのシェルではデフォルトでPATHが設定している。
PATHを追加したい場合、`bash`を使っている場合は`~/.bash_profile`に`PATH`の設定する。
システムによってはすでにPATHが設定されているが、その場合はそこに追記する。
もしPATHが設定されていない場合は次の通り設定する。

```
PATH=$PATH:/dir1/dir2:/dir10/dir20
```

ここで`$PATH`はもともと設定されている`PATH`を表し、続く`/dir1/dir2`と`/dir10/dir20`を追加するという意味になる。
`$`をつけることでただの`PATH`という文字ではなく、環境変数の`PATH`を表している。

## 開発にあたって

### エディタについて

文字だけで画面が構成されているLinuxではエディタも少々特殊なものになる。代表的なエディタとしてはVimとEmacsが挙げられる。
ここではデフォルトで入っていることが多いVimについて学ぶ。
なお、MacやWindows上で開発する場合はVisual Studio Codeというエディタをお勧めする。
無料で完成度が非常に高い上にプラグインも豊富で使っている人もかなり多い。もしまだ入れていない場合は入れておくと良い。

#### Vimとは

Vimとはテキストベースの画面でも使えるエディタのソフトである。
文字を入力する「入力モード」と、カーソルの移動、検索、保存などを行う「ノーマルモード」の2つのモードを備える。
この2つのモードを切り替えながらテキストを編集することになる。

Viｍの操作方法についてはVim自体についてくるチュートリアルが分かりやすいのでここでは解説しない。
チュートリアルを起動するには、次のコマンドを実行する。
```
vimtutor
```

### Gitについて

Gitとはバージョン管理システム(VCS)の1つで、ソースコードを誰がいつどのような変更をしたかを管理するプログラムである。
バージョン管理システムはほかにもSVNやMercurialが存在するが、Gitが事実上のデファクト・スタンダードと言ってよいほど、どの企業でも使われている。
Gitについては本書で説明しきれないほど奥が深いので、ここでは最低限の概念とコマンドを説明する。

#### コミット

Gitでは変更の単位をコミットという。
後から見返すことを考えて分かりやすいようにキリのよいタイミングでコミットを行う。

#### ブランチ

Gitではある変更に対するコミットのまとまりをブランチと呼ぶ。
ブランチは開発をする場合1つだけ作り、そこに必要な変更をコミットする場合が多い。
ブランチを作る際は既存のブランチから派生させる。派生させた新しいブランチにコミットを行い、それを既存のブランチに統合する。
ブランチを別のブランチに統合することをマージと呼ぶ。

#### チェックアウト

ブランチを切り替えることをチェックアウトと呼ぶ。
チェックアウトを行うとソースコードが自動的にそのブランチの内容に置き換わる。

#### リモートとローカル

Gitは複数人での開発を前提として開発されている。
複数人でブランチやコミットを共有するため、普通GitHubやGitLabのようなWebサービスを利用する。
開発の際にはこれらのWebサービス(リモート)から最新のブランチ・コミットを取得して開発、そして自分が作成したブランチ・コミットはほかの人も利用できるようにWebサービスに上げる。
リモートから手元(ローカル)にブランチ・コミットを取得することをプル、自分が作成した手元にあるブランチ・コミットを上げることをプッシュと呼ぶ。

#### Pull Request

GitHubやGitLabといったWebサービス(ホスティング)の機能で、ブランチを別のブランチへマージする際に、ほかの開発メンバーに内容を確認してもらうことができる。
ほかのメンバーに内容を確認してもらい、問題ないことを確認してからマージすることで安全に開発を進めることができる。

##### コマンドについて

* 手元の状態を知りたい時: `git status`
* 手元の1つ前のコミットとの差分を知りたい時: `git diff`
* コミットしたい時
    * `git add (ファイル名)`
    * `git commit -m '（コミットメッセージ）'`
* プッシュしたい時: `git push`
* プルしたい時: `git pull`
* チェックアウトしたい時: `git checkout (ブランチ名)`
* ブランチを派生させたい(新しいブランチを作る)時（派生元のブランチをチェックアウトした状態で）: `git checkout -b (ブランチ名)`

#### 実際の開発

ここまでかなり早足で概念を説明したが、なかなか頭に入らないと思われるので実際の開発を例にとって説明する。

あなたはA社のWebアプリケーションエンジニアで、ある機能の開発を依頼された。
VCSはGitを採用しており、GitHubをホスティングに利用している。

まずあなたはブランチ作成する前に(develop/my/featureというブランチ名とする)ローカル派生元ブランチ(mainというブランチ名とする)の状態を最新にしようと考える。
最新にするため次のコマンドを実行する。

```
git checkout main
git pull
```

このコマンドで派生元ブランチであるmainに切り替え、内容(コミット)を最新の状態にできる。
次に開発用の新しいブランチを作成する。次のコマンドを実行する。

```
git checkout -b develop/my/feature
```

このコマンドでdevelop/my/faetureというブランチがmainブランチに派生する形でローカルに作成される。
次に開発しソースコードを編集する。キリがよいタイミングで随時コミットを行う。次のコマンドを実行する。

```
git add (ファイル名1)
git add (ファイル名2)n
git commit -m '(コミットメッセージ)'
```

あなたはこれを繰り返して開発を終えた。
次にリモート（GitHub）にこのブランチをプッシュしたいと考える。次のコマンドを実行する。

```
git push origin develop/my/feature
```

このコマンドでGitHub(ここではoriginという設定名になっているとする。たいていはこの設定になっているはず)にdevelop/my/featureブランチが反映される。

ここまで来たらあと一息で、GitHubにブラウザでアクセスしPull Requestを作成する。作成方法はGitHubのヘルプなどを参照してほしい。

あなたはほかの開発者に内容をチェックしてもらうよう依頼をし、しばらくして問題ないと承認(approve)してもらうことができた。

最後にマージボタンを押すことで、あなたのdevelop/my/featureブランチのコミットは無事mainブランチに反映された。


この流れが基本的な開発の流れとなる。

組織によってはブランチの運用ルールがあったり、Pull Requestの作成ルールがあるが基本的にはこの流れとなっている。

これまでの操作はLinuxのGitコマンドで行っていたが、ほとんどの組織ではIDE(エディタ)を使って開発を進めており、そのエディタの機能でGitの操作もマウスで分かりやすくできる事が多い。

なので今紹介した手順はあくまで参考にしてほしい。

### SQLについて

Webアプリケーションエンジニアとして避けては通れないのがSQLである。
こちらも最低限の概念とコマンドを説明するので詳しく知りたくなった時は別に調べてほしい。

### 接続方法

MySQLの場合は次のコマンドで接続できる。接続後SQLコマンドを実行してデータの取得・更新が行える。
```
mysql -u (ユーザ名) -p -h (ホスト名) (データベース名)
```

### データ取得系

データの取得は`SELECT`というコマンドを使う。基本的なフォーマットは次の通り。
```
SELECT (カラム名) FROM (テーブル名);
```

カラム名はカンマ区切りで複数指定できる。もしくはアスタリスクを指定することでテーブルの全カラムを指定できる。

上記コマンドだとテーブルの全データが取得される。特定の条件に絞りたい場合は次にする。
```
SELECT (カラム名) FROM (テーブル名) WHERE (カラム名) = (値);
```
この場合だと`カラム名`が`値`のデータのみを取得できる。
複数のカラムの条件を絞りたい場合は次のコマンドを実行する。
```
SELECT (カラム名) FROM (テーブル名) WHERE (カラム名) = (値) AND (カラム名) = (値);
```

### 開発の心構え

この章では実際に開発にあたっての心構えを説明する。これらを実践することでキャッチアップが早くなるはずだ。

#### とりあえずやってみる

開発をしていると、幾度となくなにかがうまく行かないといった壁にぶつかる。
そういった時は焦らず思い浮かんだ方法をリストアップし、実際にそれを試してみると良い。

いろいろ試していく中でソースコードがごちゃごちゃになるかも知れないが、VCSのGitを使っていれば元の状態にすぐに戻せる。
`git add`も`git commit`もしていないファイルを元に戻すには次のコマンドを実行する。

`git checkout 戻したいファイル、もしくはディレクトリ`

もし戻したいファイルが複数ある場合は、そのファイルが含まれるディレクトリを指定すると良い。

自分がどのファイルを変更したのか、変更した内容はどういったものかは、それぞれ`git status`と`git diff`コマンドで確認できる。
そのため気になることはどんどん試してみると良い。

#### エラーはとりあえず検索してみる

開発中に何かエラーが発生することはよくある。
その時エラーが発生した！とパニックにならずに、冷静にそのエラーの内容をよく読んでほしい。
英語が分からない場合はGoogle翻訳で翻訳したり、エラーをそのままGoogle検索すると大抵の場合は解決策が見つかる。
もし見つからない場合は上司や先輩に聞くと良い。
その時にはエラーの内容をそのまま正確に伝えるとともに、どうやったらそのエラーが出たのかという手順も一緒に伝えるとより良い。

#### トラブルシューティングをやってみる

エラーをGoogle検索したり、そもそもエラーが出ない場合はトラブルシューティングをして原因や解決策を探さなければならない。
トラブルシューティングのやり方は色々あるが、一般的には次のようにすると良い。

##### printデバッグ

何かがおかしいと思われる変数の中身をログや画面に出力させる方法で、PHPなら`var_dump()`、Rubyなら`puts`などを使う。
もし想定している中身が入っていない場合はどこでその中身が入ったのかを確認し、問題箇所を修正できる。

##### デバッガを使う

開発環境によっては`pry`や`xdebug`などが使える。もし使える場合は積極的に使うことを勧める。使用方法は検索したり周りの人に聞いて欲しい。

##### 画面のエラーを見てみる

もし画面にエラーが表示されていたらまずはしっかり読んで欲しい。英語がわからなければ翻訳するなどしてまずどんなエラーが出ているのかを把握する。
その上で意味が分かればエラーの原因について考えて、分からなければエラーをGoogle検索すると大抵何か見つかるので原因が分かる。
もしくは社内のチャットツールからエラーを検索しても有用な情報が得られる場合がある。

##### ログファイルのエラーを見てみる

大抵の場合ログファイルにもエラーが出力される。
画面にエラーが出ない場合でもログファイルに出ているケースがほとんどなので、何かを確認したい場合はログファイルを見ることをおすすめする。
ログファイルの場所は開発しているシステムによって異なるので各自調べて欲しい。

###### ログファイルのtips

ログファイルは随時更新されていくため、`less`コマンドなどで普通に内容を確認しようとすると一々ファイルを開き直さないといけない。
`less`コマンドであれば`Control + f`を押すと随時読み込みモードとなってファイルが更新されるたびにファイルを読み直してくれる。
もしくは`tail`コマンドの`f`オプションを使い引数にログファイルを指定(つまり`tail -f ログファイル名`)しても同様の結果が得られる。
開発中はログファイル用のタブやウィンドウを開きっぱなしにするとよい。
